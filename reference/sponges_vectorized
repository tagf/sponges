#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Apr  9 15:41:43 2020.

@author: tagir.farkhutdinov@atco.com
"""

from collections import namedtuple
import numpy as np
# import matplotlib
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
import sympy as sy
from sympy.core import sympify
from sympy.utilities.autowrap import ufuncify


# %%
def partial(array, bc='s'):
    """Compute central discrete differences.

    The assumed inputs are X - x and Y - x.
    Example : partial X over x = partial(solid, 's') + 1.
    """
    result = np.correlate(array, np.array([-0.5, 0., 0.5]), mode='same')
    bc = 'periodic'
    if bc in ('f', 'fluid'):
        result[0] -= 0.5 * array[0]
        result[-1] += 0.5 * array[-1]
    elif bc in ('s', 'solid'):
        result[0] -= 0.
        result[-1] += 0.
    elif bc in ('periodic'):
        result[0] -= 0.5 * array[-1]
        result[-1] += 0.5 * array[0]
    else:
        raise ValueError("Please specify valid boundary conditions.")
    return result


def partial2(array, bc='s'):
    """Compute the second discrete differences.

    The assumed inputs are X and Y.
    Example : partial2 X over x2 = partial2(solid, 's')/partial_x**2.
    """
    result = np.correlate(array, np.array([1., -2., 1.]), mode='same')
    bc = 'periodic'
    if bc in ('f', 'fluid'):
        result[0] += array[0]
        result[-1] += array[-1]
    elif bc in ('s', 'solid'):
        result[0] += 0.
        result[-1] += 0.
    elif bc in ('periodic'):
        result[0] += array[-1]
        result[-1] += array[0]
    else:
        raise ValueError("Please specify valid boundary conditions.")
    return result


symb_input = sy.symbols("time, x_coord, "
                        "solid, solid_t, density_s, laplace_s,"
                        "fluid, fluid_t, density_f, laplace_f")

symb_input += sy.symbols('rho_s, rho_f, g_0, K, '
                         'param_a, param_b, S_0, nu, W, U,'
                         'domain_half_length')

friction = ufuncify(symb_input,
                    sympify('K * ('
                            'solid_t / density_s - fluid_t / density_f'
                            ')')
                    )


pressure = ufuncify(symb_input,
                    sympify(
                        '2 * param_b * g_0 * density_f * '
                        '(g_0**2 * laplace_f + (1 - g_0) * laplace_s)'))

sigma = ufuncify(symb_input,
                 sympify(
                     '- 2. * param_a * density_s * laplace_s'
                     '- 2. * param_b'
                     '* (g_0**2*density_f + (1. - g_0)*density_s)'
                     '* (g_0**2*laplace_f + (1. - g_0)*laplace_s)'
                     )
                 )


dynamic = ufuncify(sy.symbols('F_t, F_tx, density, laplace'),
                   sympify('F_t / density * '
                           '(laplace * (F_t / density)'
                           '- 2 * (F_tx))')
                   )


def stress_term(time, solid, solid_plus_x, partial_x,
                domain_half_length,
                stress_args=(1., 1.)):
    """Compute partial of (sigma_epsilon + S) / partial_x term."""
    W, U = stress_args
    X1 = np.mod((solid_plus_x)-U*time,
                2*domain_half_length) - domain_half_length
    # partX_x = partial(solid, 's')/partial_x + 1.
    stress = np.exp(-(X1)**2/W**2)
#    stress_x = (-2. * partX_x * (X1)  *
#                np.exp(-(X1)**2/W**2) / W**2
#                )

    return stress


# %%

Statement = namedtuple('ProblemStatement',
                       ["number_of_intervals",
                        "domain_half_length",
                        "time_interval"])

Solution = namedtuple('ProblemSolution',
                      "x_coord, solid, solid_t, fluid, fluid_t")


def solve(problem_statement):
    """Solve PDE by reduction to IVP for ODE."""
    (number_of_intervals,
     domain_half_length,
     time_interval) = problem_statement
    x_coordinate = np.linspace(-domain_half_length,
                               domain_half_length,
                               number_of_intervals + 1)

    # Solid and fluid represent alpha and beta correspondingly
    solid = np.zeros_like(x_coordinate)
    fluid = np.zeros_like(x_coordinate)
    solid_t = np.zeros_like(solid)
    fluid_t = np.zeros_like(fluid)

    result = solve_ivp(time_step,
                       (time_interval[0], time_interval[-1]),
                       y0=np.hstack((solid, solid_t, fluid, fluid_t)),
                       method='Radau',
                       t_eval=time_interval,  # time_interval,
                       vectorized=True,
                       args=(x_coordinate,)
                       )

    if not isinstance(time_interval, np.ndarray):
        plt.plot(result.t)
        plt.title('Time (y) vs time steps (x).')
        plt.show()

    return Solution(x_coordinate,
                    *np.split(result.y.T, 4, axis=1))


time_step_counter = 0
multipl_counter = 0


def time_step(time, y, *args):
    """Compute one time step."""
    # pylint: disable=R0914
    global time_step_counter, multipl_counter
    time_step_counter += 1
    multipl_counter += y.shape[1]

    solid, solid_t, fluid, fluid_t = np.split(y, 4)
    x_coord = np.broadcast_to(args[0].reshape(-1, 1),
                              (args[0].size, y.shape[1]))
    domain_half_length = x_coord[-1, 0]
    partial_x = 2.*domain_half_length/(x_coord.size - 1)
    rho_s = 1.
    rho_f = 1.
    # lamda = 0.5
    g_0 = 0.5
    K = 1
    param_a = 1.
    param_b = 1.0
    S_0 = 0.1
    nu = 0.0
    W, U = 1, 1

    def apply_(arr, func):
        cols = range(arr.shape[1])
        return np.vstack([func(arr[:, i].T, 's') for i in cols]).T

    density_s = apply_(solid, partial)/partial_x + 1.
    density_f = apply_(fluid, partial)/partial_x + 1.
    laplace_s = apply_(solid, partial2)/partial_x**2
    laplace_f = apply_(fluid, partial2)/partial_x**2

    layer_data = (time, x_coord,
                  solid, solid_t, density_s, laplace_s,
                  fluid, fluid_t, density_f, laplace_f)

    problem_consts = (rho_s, rho_f, g_0, K,
                      param_a, param_b, S_0, nu, W, U,
                      domain_half_length)

    friction_ = friction(*(layer_data + problem_consts))
    pressure_ = pressure(*(layer_data + problem_consts))
    sigma_ = sigma(*(layer_data + problem_consts))

    stress_ = S_0 * stress_term(time, solid,
                                solid + x_coord,
                                partial_x,
                                domain_half_length)
    stress_ = apply_(stress_, partial)/partial_x
    sigma_and_stress = stress_ + sigma_

    delta_solid_t = (- dynamic(solid_t,
                               apply_(solid_t, partial)/partial_x,
                               density_s, laplace_s)
                     - (friction_
                        + pressure_
                        + sigma_and_stress) / rho_s
                     )
    delta_fluid_t = (- dynamic(fluid_t,
                               apply_(fluid_t, partial)/partial_x,
                               density_f, laplace_f)
                     + (friction_ + pressure_) / (g_0 * rho_f))

    return np.vstack((solid_t + nu * laplace_s,
                      delta_solid_t,
                      fluid_t + nu * laplace_f,
                      delta_fluid_t))


def solve_instance():
    """Solve problem instance."""
    # pylint: disable=W0612
    end_time = 300.
    statement = Statement(number_of_intervals=128,
                          domain_half_length=4.,
                          time_interval=np.linspace(0., end_time,
                                                    int(1.024 * end_time)))

    return statement, solve(statement)


STATEMENT, SOLUTION = solve_instance()
